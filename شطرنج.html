<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>بازی شطرنج</title>
    <style type="text/css" media="all">
      body {
  font-family: 'Arial', sans-serif;
  background-color: #f5f5f5;
  margin: 0;
  padding: 20px;
  text-align: center;
}

.chess-container {
  max-width: 600px;
  margin: 0 auto;
  background-color: white;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

h1 {
  color: #333;
}

#chessboard {
  display: grid;
  grid-template-columns: repeat(8, 30px);
  grid-template-rows: repeat(8, 30px);
  gap: 0;
  margin: 20px auto;
  border: 2px solid #333;
  width: 270px;
}

.square {
  width: 30px;
  height: 30px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 40px;
}

.light {
  background-color: #f0d9b5;
}

.dark {
  background-color: #b58863;
}

.selected {
  background-color: rgba(0, 255, 0, 0.5);
}

.possible-move {
  background-color: rgba(0, 0, 255, 0.3);
}

#status {
  margin: 20px 0;
  font-size: 18px;
  font-weight: bold;
}

#reset {
  padding: 10px 20px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
}

#reset:hover {
  background-color: #45a049;
}
    </style>
  </head>
  <body>
    <div class="chess-container">بازی شطرنج</h1>
        <div id="chessboard"></div>
        <div id="status"></div>
        <button id="reset">بازی مجدد</button>
    </div>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
    const chessboard = document.getElementById('chessboard');
    const statusDiv = document.getElementById('status');
    const resetButton = document.getElementById('reset');
    
    let selectedPiece = null;
    let currentPlayer = 'white';
    let gameState = initializeBoard();
    
    // Initialize the chessboard
    function initializeBoard() {
        const board = Array(8).fill().map(() => Array(8).fill(null));
        
        // Set up pawns
        for (let i = 0; i < 8; i++) {
            board[1][i] = { type: 'pawn', color: 'black' };
            board[6][i] = { type: 'pawn', color: 'white' };
        }
        
        // Set up rooks
        board[0][0] = board[0][7] = { type: 'rook', color: 'black' };
        board[7][0] = board[7][7] = { type: 'rook', color: 'white' };
        
        // Set up knights
        board[0][1] = board[0][6] = { type: 'knight', color: 'black' };
        board[7][1] = board[7][6] = { type: 'knight', color: 'white' };
        
        // Set up bishops
        board[0][2] = board[0][5] = { type: 'bishop', color: 'black' };
        board[7][2] = board[7][5] = { type: 'bishop', color: 'white' };
        
        // Set up queens
        board[0][3] = { type: 'queen', color: 'black' };
        board[7][3] = { type: 'queen', color: 'white' };
        
        // Set up kings
        board[0][4] = { type: 'king', color: 'black' };
        board[7][4] = { type: 'king', color: 'white' };
        
        return board;
    }
    
    // Render the chessboard
    function renderBoard() {
        chessboard.innerHTML = '';
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');
                square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                square.dataset.row = row;
                square.dataset.col = col;
                
                const piece = gameState[row][col];
                if (piece) {
                    square.textContent = getPieceSymbol(piece);
                    square.style.color = piece.color === 'white' ? '#fff' : '#000';
                }
                
                square.addEventListener('click', () => handleSquareClick(row, col));
                chessboard.appendChild(square);
            }
        }
        
        statusDiv.textContent = `نوبت: ${currentPlayer === 'white' ? 'سفید' : 'سیاه'}`;
    }
    
    // Get Unicode symbol for a chess piece
    function getPieceSymbol(piece) {
        const symbols = {
            king: { white: '♔', black: '♚' },
            queen: { white: '♕', black: '♛' },
            rook: { white: '♖', black: '♜' },
            bishop: { white: '♗', black: '♝' },
            knight: { white: '♘', black: '♞' },
            pawn: { white: '♙', black: '♟' }
        };
        return symbols[piece.type][piece.color];
    }
    
    // Handle square click
    function handleSquareClick(row, col) {
        const piece = gameState[row][col];
        
        // If no piece is selected and the clicked square has a piece of the current player's color
        if (!selectedPiece && piece && piece.color === currentPlayer) {
            selectedPiece = { row, col, piece };
            highlightSquare(row, col, true);
            highlightPossibleMoves(row, col);
            return;
        }
        
        // If a piece is already selected
        if (selectedPiece) {
            // If clicking on another piece of the same color, select that piece instead
            if (piece && piece.color === currentPlayer) {
                clearHighlights();
                selectedPiece = { row, col, piece };
                highlightSquare(row, col, true);
                highlightPossibleMoves(row, col);
                return;
            }
            
            // Check if the move is valid
            if (isValidMove(selectedPiece.row, selectedPiece.col, row, col)) {
                // Move the piece
                gameState[row][col] = selectedPiece.piece;
                gameState[selectedPiece.row][selectedPiece.col] = null;
                
                // Switch player
                currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                
                // Check for pawn promotion
                checkPawnPromotion(row, col);
            }
            
            // Reset selection
            clearHighlights();
            selectedPiece = null;
            renderBoard();
        }
    }
    
    // Highlight a square
    function highlightSquare(row, col, isSelected) {
        const index = row * 8 + col;
        const square = chessboard.children[index];
        square.classList.add(isSelected ? 'selected' : 'possible-move');
    }
    
    // Clear all highlights
    function clearHighlights() {
        const squares = chessboard.querySelectorAll('.square');
        squares.forEach(square => {
            square.classList.remove('selected', 'possible-move');
        });
    }
    
    // Highlight possible moves
    function highlightPossibleMoves(row, col) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (isValidMove(row, col, r, c)) {
                    highlightSquare(r, c, false);
                }
            }
        }
    }
    
    // Check if a move is valid (simplified rules)
    function isValidMove(fromRow, fromCol, toRow, toCol) {
        const piece = gameState[fromRow][fromCol];
        if (!piece) return false;
        
        // Can't move to the same square
        if (fromRow === toRow && fromCol === toCol) return false;
        
        // Can't capture your own piece
        const targetPiece = gameState[toRow][toCol];
        if (targetPiece && targetPiece.color === piece.color) return false;
        
        // Basic movement rules (simplified)
        switch (piece.type) {
            case 'pawn':
                const direction = piece.color === 'white' ? -1 : 1;
                // Move forward
                if (fromCol === toCol && !targetPiece) {
                    // Single move forward
                    if (toRow === fromRow + direction) return true;
                    // Double move from starting position
                    if ((piece.color === 'white' && fromRow === 6) || 
                        (piece.color === 'black' && fromRow === 1)) {
                        if (toRow === fromRow + 2 * direction && 
                            !gameState[fromRow + direction][fromCol]) {
                            return true;
                        }
                    }
                }
                // Capture diagonally
                if (Math.abs(toCol - fromCol) === 1 && 
                    toRow === fromRow + direction && 
                    targetPiece && targetPiece.color !== piece.color) {
                    return true;
                }
                break;
                
            case 'rook':
                if (fromRow === toRow || fromCol === toCol) {
                    return isPathClear(fromRow, fromCol, toRow, toCol);
                }
                break;
                
            case 'knight':
                return (Math.abs(toRow - fromRow) === 2 && Math.abs(toCol - fromCol) === 1) || 
                       (Math.abs(toRow - fromRow) === 1 && Math.abs(toCol - fromCol) === 2);
                
            case 'bishop':
                if (Math.abs(toRow - fromRow) === Math.abs(toCol - fromCol)) {
                    return isPathClear(fromRow, fromCol, toRow, toCol);
                }
                break;
                
            case 'queen':
                if ((fromRow === toRow || fromCol === toCol) || 
                    (Math.abs(toRow - fromRow) === Math.abs(toCol - fromCol))) {
                    return isPathClear(fromRow, fromCol, toRow, toCol);
                }
                break;
                
            case 'king':
                return Math.abs(toRow - fromRow) <= 1 && Math.abs(toCol - fromCol) <= 1;
        }
        
        return false;
    }
    
    // Check if path between two squares is clear
    function isPathClear(fromRow, fromCol, toRow, toCol) {
        const rowStep = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
        const colStep = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
        
        let row = fromRow + rowStep;
        let col = fromCol + colStep;
        
        while (row !== toRow || col !== toCol) {
            if (gameState[row][col] !== null) return false;
            row += rowStep;
            col += colStep;
        }
        
        return true;
    }
    
    // Check for pawn promotion (simplified - always promotes to queen)
    function checkPawnPromotion(row, col) {
        const piece = gameState[row][col];
        if (piece && piece.type === 'pawn' && (row === 0 || row === 7)) {
            piece.type = 'queen';
        }
    }
    
    // Reset the game
    resetButton.addEventListener('click', () => {
        gameState = initializeBoard();
        currentPlayer = 'white';
        selectedPiece = null;
        renderBoard();
    });
    
    // Initial render
    renderBoard();
});
    </script>

  </body>
</html>